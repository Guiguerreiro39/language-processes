<html> <head> <meta charset='UTF-8'/> <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"> </head> <body>
<style>table, th, td {border: 1px solid black;border-collapse: collapse; margin-left: 15%;}th, td {padding: 3px;text-align: center;} body{margin-left: 20px; margin-right: 20px;}</style>
<li><a href="home.html"> Voltar </a></li>
<h1 style="text-align: center;"> Texto com InglÃªs corrente </h1>
<hr>
:tocdepth: 2<br><br>===============<br>Programming FAQ<br>===============<br><br>.. only:: html<br><br>   .. contents::<br><br>General Questions<br>=================<br><br>Is there a source code level debugger with breakpoints, single-stepping, etc.?<br>------------------------------------------------------------------------------<br><br>Yes.<br><br>The pdb module is a simple but adequate console-mode debugger for Python. It is<br>part of the standard Python library, and is :mod:`documented in the Library<br>Reference Manual <pdb>`. You can also write your own debugger by using the code<br>for pdb as an example.<br><br>The IDLE interactive development environment, which is part of the standard<br>Python distribution (normally available as Tools/scripts/idle), includes a<br>graphical debugger.<br><br>PythonWin is a Python IDE that includes a GUI debugger based on pdb.  The<br>Pythonwin debugger colors breakpoints and has quite a few cool features such as<br>debugging non-Pythonwin programs.  Pythonwin is available as part of the `Python<br>for Windows Extensions <https://sourceforge.net/projects/pywin32/>`__ project and<br>as a part of the ActivePython distribution (see<br>https://www.activestate.com/activepython\ ).<br><br>`Boa Constructor <http://boa-constructor.sourceforge.net/>`_ is an IDE and GUI<br>builder that uses wxWidgets.  It offers visual frame creation and manipulation,<br>an object inspector, many views on the source like object browsers, inheritance<br>hierarchies, doc string generated html documentation, an advanced debugger,<br>integrated help, and Zope support.<br><br>`Eric <http://eric-ide.python-projects.org/>`_ is an IDE built on PyQt<br>and the Scintilla editing component.<br><br>Pydb is a version of the standard Python debugger pdb, modified for use with DDD<br>(Data Display Debugger), a popular graphical debugger front end.  Pydb can be<br>found at http://bashdb.sourceforge.net/pydb/ and DDD can be found at<br>https://www.gnu.org/software/ddd.<br><br>There are a number of commercial Python IDEs that include graphical debuggers.<br>They include:<br><br>* Wing IDE (https://wingware.com/)<br>* Komodo IDE (https://komodoide.com/)<br>* PyCharm (https://www.jetbrains.com/pycharm/)<br><br><br>Is there a tool to help find bugs or perform static analysis?<br>-------------------------------------------------------------<br><br>Yes.<br><br>PyChecker is a static analysis tool that finds bugs in Python source code and<br>warns about code complexity and style.  You can get PyChecker from<br>http://pychecker.sourceforge.net/.<br><br>`Pylint <https://www.pylint.org/>`_ is another tool that checks<br>if a module satisfies a coding standard, and also makes it possible to write<br>plug-ins to add a custom feature.  In addition to the bug checking that<br>PyChecker performs, Pylint offers some additional features such as checking line<br>length, whether variable names are well-formed according to your coding<br>standard, whether declared interfaces are fully implemented, and more.<br>https://docs.pylint.org/ provides a full list of Pylint is features.<br><br><br>How can I create a stand-alone binary from a Python script?<br>-----------------------------------------------------------<br><br>You do not need the ability to compile Python to C code if all you want is a<br>stand-alone program that users can download and run without having to install<br>the Python distribution first.  There are a number of tools that determine the<br>set of modules required by a program and bind these modules together with a<br>Python binary to produce a single executable.<br><br>One is to use the freeze tool, which is included in the Python source tree as<br>``Tools/freeze``. It converts Python byte code to C arrays; a C compiler you can<br>embed all your modules into a new program, which is then linked with the<br>standard Python modules.<br><br>It works by scanning your source recursively for import statements (in both<br>forms) and looking for the modules in the standard Python path as well as in the<br>source directory (for built-in modules).  It then turns the bytecode for modules<br>written in Python into C code (array initializers that can be turned into code<br>objects using the marshal module) and creates a custom-made config file that<br>only contains those built-in modules which are actually used in the program.  It<br>then compiles the generated C code and links it with the rest of the Python<br>interpreter to form a self-contained binary which acts exactly like your script.<br><br>Obviously, freeze requires a C compiler.  There are several other utilities<br>which do not. One is Thomas Heller is py2exe (Windows only) at<br><br>    http://www.py2exe.org/<br><br>Another tool is Anthony Tuininga is `cx_Freeze <http://cx-freeze.sourceforge.net/>`_.<br><br><br>Are there coding standards or a style guide for Python programs?<br>----------------------------------------------------------------<br><br>Yes.  The coding style required for standard library modules is documented as<br>:pep:`8`.<br><br><br>Core Language<br>=============<br><br>Why am I getting an UnboundLocalError when the variable has a value?<br>--------------------------------------------------------------------<br><br>It can be a surprise to get the UnboundLocalError in previously working<br>code when it is modified by adding an assignment statement somewhere in<br>the body of a function.<br><br>This code:<br><br>   >>> x = 10<br>   >>> def bar():<br>   ...     print(x)<br>   >>> bar()<br>   10<br><br>works, but this code:<br><br>   >>> x = 10<br>   >>> def foo():<br>   ...     print(x)<br>   ...     x += 1<br><br>results in an UnboundLocalError:<br><br>   >>> foo()<br>   Traceback (most recent call last):<br>     ...<br>   UnboundLocalError: local variable 'x' referenced before assignment<br><br>This is because when you make an assignment to a variable in a scope, that<br>variable becomes local to that scope and shadows any similarly named variable<br>in the outer scope.  Since the last statement in foo assigns a new value to<br>``x``, the compiler recognizes it as a local variable.  Consequently when the<br>earlier ``print(x)`` attempts to print the uninitialized local variable and<br>an error results.<br><br>In the example above you can access the outer scope variable by declaring it<br>global:<br><br>   >>> x = 10<br>   >>> def foobar():<br>   ...     global x<br>   ...     print(x)<br>   ...     x += 1<br>   >>> foobar()<br>   10<br><br>This explicit declaration is required in order to remind you that (unlike the<br>superficially analogous situation with class and instance variables) you are<br>actually modifying the value of the variable in the outer scope:<br><br>   >>> print(x)<br>   11<br><br>You can do a similar thing in a nested scope using the :keyword:`nonlocal`<br>keyword:<br><br>   >>> def foo():<br>   ...    x = 10<br>   ...    def bar():<br>   ...        nonlocal x<br>   ...        print(x)<br>   ...        x += 1<br>   ...    bar()<br>   ...    print(x)<br>   >>> foo()<br>   10<br>   11<br><br><br>What are the rules for local and global variables in Python?<br>------------------------------------------------------------<br><br>In Python, variables that are only referenced inside a function are implicitly<br>global.  If a variable is assigned a value anywhere within the function is body,<br>it is assumed to be a local unless explicitly declared as global.<br><br>Though a bit surprising at first, a moment is consideration explains this.  On<br>one hand, requiring :keyword:`global` for assigned variables provides a bar<br>against unintended side-effects.  On the other hand, if ``global`` was required<br>for all global references, you would be using ``global`` all the time.  You would have<br>to declare as global every reference to a built-in function or to a component of<br>an imported module.  This clutter would defeat the usefulness of the ``global``<br>declaration for identifying side-effects.<br><br><br>Why do lambdas defined in a loop with different values all return the same result?<br>----------------------------------------------------------------------------------<br><br>Assume you use a for loop to define a few different lambdas (or even plain<br>functions), e.g.::<br><br>   >>> squares = []<br>   >>> for x in range(5):<br>   ...     squares.append(lambda: x**2)<br><br>This gives you a list that contains 5 lambdas that calculate ``x**2``.  You<br>might expect that, when called, they would return, respectively, ``0``, ``1``,<br>``4``, ``9``, and ``16``.  However, when you actually try you will see that<br>they all return ``16``::<br><br>   >>> squares[2]()<br>   16<br>   >>> squares[4]()<br>   16<br><br>This happens because ``x`` is not local to the lambdas, but is defined in<br>the outer scope, and it is accessed when the lambda is called --- not when it<br>is defined.  At the end of the loop, the value of ``x`` is ``4``, so all the<br>functions now return ``4**2``, i.e. ``16``.  You can also verify this by<br>changing the value of ``x`` and see how the results of the lambdas change::<br><br>   >>> x = 8<br>   >>> squares[2]()<br>   64<br><br>In order to avoid this, you need to save the values in variables local to the<br>lambdas, so that they do not rely on the value of the global ``x``::<br><br>   >>> squares = []<br>   >>> for x in range(5):<br>   ...     squares.append(lambda n=x: n**2)<br><br>Here, ``n=x`` creates a new variable ``n`` local to the lambda and computed<br>when the lambda is defined so that it has the same value that ``x`` had at<br>that point in the loop.  This means that the value of ``n`` will be ``0``<br>in the first lambda, ``1`` in the second, ``2`` in the third, and so on.<br>Therefore each lambda will now return the correct result::<br><br>   >>> squares[2]()<br>   4<br>   >>> squares[4]()<br>   16<br><br>Note that this behaviour is not peculiar to lambdas, but applies to regular<br>functions too.<br><br><br>How do I share global variables across modules?<br>------------------------------------------------<br><br>The canonical way to share information across modules within a single program is<br>to create a special module (often called config or cfg).  Just import the config<br>module in all modules of your application; the module then becomes available as<br>a global name.  Because there is only one instance of each module, any changes<br>made to the module object get reflected everywhere.  For example:<br><br>config.py::<br><br>   x = 0   # Default value of the 'x' configuration setting<br><br>mod.py::<br><br>   import config<br>   config.x = 1<br><br>main.py::<br><br>   import config<br>   import mod<br>   print(config.x)<br><br>Note that using a module is also the basis for implementing the Singleton design<br>pattern, for the same reason.<br><br><br>What are the "best practices" for using import in a module?<br>-----------------------------------------------------------<br><br>In general, do not use ``from modulename import *``.  Doing so clutters the<br>importer is namespace, and makes it much harder for linters to detect undefined<br>names.<br><br>Import modules at the top of a file.  Doing so makes it clear what other modules<br>your code requires and avoids questions of whether the module name is in scope.<br>Using one import per line makes it easy to add and delete module imports, but<br>using multiple imports per line uses less screen space.<br><br>It is good practice if you import modules in the following order:<br><br>1. standard library modules -- e.g. ``sys``, ``os``, ``getopt``, ``re``<br>2. third-party library modules (anything installed in Python is site-packages<br>   directory) -- e.g. mx.DateTime, ZODB, PIL.Image, etc.<br>3. locally-developed modules<br><br>It is sometimes necessary to move imports to a function or class to avoid<br>problems with circular imports.  Gordon McMillan says:<br><br>   Circular imports are fine where both modules use the "import <module>" form<br>   of import.  They fail when the 2nd module wants to grab a name out of the<br>   first ("from module import name") and the import is at the top level.  That is<br>   because names in the 1st are not yet available, because the first module is<br>   busy importing the 2nd.<br><br>In this case, if the second module is only used in one function, then the import<br>can easily be moved into that function.  By the time the import is called, the<br>first module will have finished initializing, and the second module can do its<br>import.<br><br>It may also be necessary to move imports out of the top level of code if some of<br>the modules are platform-specific.  In that case, it may not even be possible to<br>import all of the modules at the top of the file.  In this case, importing the<br>correct modules in the corresponding platform-specific code is a good option.<br><br>Only move imports into a local scope, such as inside a function definition, if<br>it is necessary to solve a problem such as avoiding a circular import or are<br>trying to reduce the initialization time of a module.  This technique is<br>especially helpful if many of the imports are unnecessary depending on how the<br>program executes.  You may also want to move imports into a function if the<br>modules are only ever used in that function.  Note that loading a module the<br>first time may be expensive because of the one time initialization of the<br>module, but loading a module multiple times is virtually free, costing only a<br>couple of dictionary lookups.  Even if the module name has gone out of scope,<br>the module is probably available in :data:`sys.modules`.<br><br><br>Why are default values shared between objects?<br>----------------------------------------------<br><br>This type of bug commonly bites neophyte programmers.  Consider this function::<br><br>   def foo(mydict={}):  # Danger: shared reference to one dict for all calls<br>       ... compute something ...<br>       mydict[key] = value<br>       return mydict<br><br>The first time you call this function, ``mydict`` contains a single item.  The<br>second time, ``mydict`` contains two items because when ``foo()`` begins<br>executing, ``mydict`` starts out with an item already in it.<br><br>It is often expected that a function call creates new objects for default<br>values. This is not what happens. Default values are created exactly once, when<br>the function is defined.  If that object is changed, like the dictionary in this<br>example, subsequent calls to the function will refer to this changed object.<br><br>By definition, immutable objects such as numbers, strings, tuples, and ``None``,<br>are safe from change. Changes to mutable objects such as dictionaries, lists,<br>and class instances can lead to confusion.<br><br>Because of this feature, it is good programming practice to not use mutable<br>objects as default values.  Instead, use ``None`` as the default value and<br>inside the function, check if the parameter is ``None`` and create a new<br>list/dictionary/whatever if it is.  For example, do not write::<br><br>   def foo(mydict={}):<br>       ...<br><br>but::<br><br>   def foo(mydict=None):<br>       if mydict is None:<br>           mydict = {}  # create a new dict for local namespace<br><br>This feature can be useful.  When you have a function that is time-consuming to<br>compute, a common technique is to cache the parameters and the resulting value<br>of each call to the function, and return the cached value if the same value is<br>requested again.  This is called "memoizing", and can be implemented like this::<br><br>   # Callers will never provide a third parameter for this function.<br>   def expensive(arg1, arg2, _cache={}):<br>       if (arg1, arg2) in _cache:<br>           return _cache[(arg1, arg2)]<br><br>       # Calculate the value<br>       result = ... expensive computation ...<br>       _cache[(arg1, arg2)] = result           # Store result in the cache<br>       return result<br><br>You could use a global variable containing a dictionary instead of the default<br>value; it is a matter of taste.<br><br><br>How can I pass optional or keyword parameters from one function to another?<br>---------------------------------------------------------------------------<br><br>Collect the arguments using the ``*`` and ``**`` specifiers in the function is<br>parameter list; this gives you the positional arguments as a tuple and the<br>keyword arguments as a dictionary.  You can then pass these arguments when<br>calling another function by using ``*`` and ``**``::<br><br>   def f(x, *args, **kwargs):<br>       ...<br>       kwargs['width'] = '14.3c'<br>       ...<br>       g(x, *args, **kwargs)<br><br><br>.. index::<br>   single: argument; difference from parameter<br>   single: parameter; difference from argument<br><br>.. _faq-argument-vs-parameter:<br><br>What is the difference between arguments and parameters?<br>--------------------------------------------------------<br><br>:term:`Parameters <parameter>` are defined by the names that appear in a<br>function definition, whereas :term:`arguments <argument>` are the values<br>actually passed to a function when calling it.  Parameters define what types of<br>arguments a function can accept.  For example, given the function definition::<br><br>   def func(foo, bar=None, **kwargs):<br>       pass<br><br>*foo*, *bar* and *kwargs* are parameters of ``func``.  However, when calling<br>``func``, for example::<br><br>   func(42, bar=314, extra=somevar)<br><br>the values ``42``, ``314``, and ``somevar`` are arguments.<br><br><br>Why did changing list 'y' also change list 'x'?<br>------------------------------------------------<br><br>If you wrote code like::<br><br>   >>> x = []<br>   >>> y = x<br>   >>> y.append(10)<br>   >>> y<br>   [10]<br>   >>> x<br>   [10]<br><br>you might be wondering why appending an element to ``y`` changed ``x`` too.<br><br>There are two factors that produce this result:<br><br>1) Variables are simply names that refer to objects.  Doing ``y = x`` does not<br>   create a copy of the list -- it creates a new variable ``y`` that refers to<br>   the same object ``x`` refers to.  This means that there is only one object<br>   (the list), and both ``x`` and ``y`` refer to it.<br>2) Lists are :term:`mutable`, which means that you can change their content.<br><br>After the call to :meth:`~list.append`, the content of the mutable object has<br>changed from ``[]`` to ``[10]``.  Since both the variables refer to the same<br>object, using either name accesses the modified value ``[10]``.<br><br>If we instead assign an immutable object to ``x``::<br><br>   >>> x = 5  # ints are immutable<br>   >>> y = x<br>   >>> x = x + 1  # 5  not be mutated, we are creating a new object here<br>   >>> x<br>   6<br>   >>> y<br>   5<br><br>we can see that in this case ``x`` and ``y`` are not equal anymore.  This is<br>because integers are :term:`immutable`, and when we do ``x = x + 1`` we are not<br>mutating the int ``5`` by incrementing its value; instead, we are creating a<br>new object (the int ``6``) and assigning it to ``x`` (that is, changing which<br>object ``x`` refers to).  After this assignment we have two objects (the ints<br>``6`` and ``5``) and two variables that refer to them (``x`` now refers to<br>``6`` but ``y`` still refers to ``5``).<br><br>Some operations (for example ``y.append(10)`` and ``y.sort()``) mutate the<br>object, whereas superficially similar operations (for example ``y = y + [10]``<br>and ``sorted(y)``) create a new object.  In general in Python (and in all cases<br>in the standard library) a method that mutates an object will return ``None``<br>to help avoid getting the two types of operations confused.  So if you<br>mistakenly write ``y.sort()`` thinking it will give you a sorted copy of ``y``,<br>you will instead end up with ``None``, which will likely cause your program to<br>generate an easily diagnosed error.<br><br>However, there is one class of operations where the same operation sometimes<br>has different behaviors with different types:  the augmented assignment<br>operators.  For example, ``+=`` mutates lists but not tuples or ints (``a_list<br>+= [1, 2, 3]`` is equivalent to ``a_list.extend([1, 2, 3])`` and mutates<br>``a_list``, whereas ``some_tuple += (1, 2, 3)`` and ``some_int += 1`` create<br>new objects).<br><br>In other words:<br><br>* If we have a mutable object (:class:`list`, :class:`dict`, :class:`set`,<br>  etc.), we can use some specific operations to mutate it and all the variables<br>  that refer to it will see the change.<br>* If we have an immutable object (:class:`str`, :class:`int`, :class:`tuple`,<br>  etc.), all the variables that refer to it will always see the same value,<br>  but operations that transform that value into a new value always return a new<br>  object.<br><br>If you want to know if two variables refer to the same object or not, you can<br>use the :keyword:`is` operator, or the built-in function :func:`id`.<br><br><br>How do I write a function with output parameters (call by reference)?<br>---------------------------------------------------------------------<br><br>Remember that arguments are passed by assignment in Python.  Since assignment<br>just creates references to objects, there is no alias between an argument name in<br>the caller and callee, and so no call-by-reference per se.  You can achieve the<br>desired effect in a number of ways.<br><br>1) By returning a tuple of the results::<br><br>      def func2(a, b):<br>          a = 'new-value'        # a and b are local names<br>          b = b + 1              # assigned to new objects<br>          return a, b            # return new values<br><br>      x, y = 'old-value', 99<br>      x, y = func2(x, y)<br>      print(x, y)                # output: new-value 100<br><br>   This is almost always the clearest solution.<br><br>2) By using global variables.  This is not thread-safe, and is not recommended.<br><br>3) By passing a mutable (changeable in-place) object::<br><br>      def func1(a):<br>          a[0] = 'new-value'     # 'a' references a mutable list<br>          a[1] = a[1] + 1        # changes a shared object<br><br>      args = ['old-value', 99]<br>      func1(args)<br>      print(args[0], args[1])    # output: new-value 100<br><br>4) By passing in a dictionary that gets mutated::<br><br>      def func3(args):<br>          args['a'] = 'new-value'     # args is a mutable dictionary<br>          args['b'] = args['b'] + 1   # change it in-place<br><br>      args = {'a': 'old-value', 'b': 99}<br>      func3(args)<br>      print(args['a'], args['b'])<br><br>5) Or bundle up values in a class instance::<br><br>      class callByRef:<br>          def __init__(self, **args):<br>              for (key, value) in args.items():<br>                  setattr(self, key, value)<br><br>      def func4(args):<br>          args.a = 'new-value'        # args is a mutable callByRef<br>          args.b = args.b + 1         # change object in-place<br><br>      args = callByRef(a='old-value', b=99)<br>      func4(args)<br>      print(args.a, args.b)<br><br><br>   There is almost never a good reason to get this complicated.<br><br>Your best choice is to return a tuple containing the multiple results.<br><br><br>How do you make a higher order function in Python?<br>--------------------------------------------------<br><br>You have two choices: you can use nested scopes or you can use callable objects.<br>For example, suppose you wanted to define ``linear(a,b)`` which returns a<br>function ``f(x)`` that computes the value ``a*x+b``.  Using nested scopes::<br><br>   def linear(a, b):<br>       def result(x):<br>           return a * x + b<br>       return result<br><br>Or using a callable object::<br><br>   class linear:<br><br>       def __init__(self, a, b):<br>           self.a, self.b = a, b<br><br>       def __call__(self, x):<br>           return self.a * x + self.b<br><br>In both cases, ::<br><br>   taxes = linear(0.3, 2)<br><br>gives a callable object where ``taxes(10e6) == 0.3 * 10e6 + 2``.<br><br>The callable object approach has the disadvantage that it is a bit slower and<br>results in slightly longer code.  However, note that a collection of callables<br>can share their signature via inheritance::<br><br>   class exponential(linear):<br>       # __init__ inherited<br>       def __call__(self, x):<br>           return self.a * (x ** self.b)<br><br>Object can encapsulate state for several methods::<br><br>   class counter:<br><br>       value = 0<br><br>       def set(self, x):<br>           self.value = x<br><br>       def up(self):<br>           self.value = self.value + 1<br><br>       def down(self):<br>           self.value = self.value - 1<br><br>   count = counter()<br>   inc, dec, reset = count.up, count.down, count.set<br><br>Here ``inc()``, ``dec()`` and ``reset()`` act like functions which share the<br>same counting variable.<br><br><br>How do I copy an object in Python?<br>----------------------------------<br><br>In general, try :func:`copy.copy` or :func:`copy.deepcopy` for the general case.<br>Not all objects can be copied, but most can.<br><br>Some objects can be copied more easily.  Dictionaries have a :meth:`~dict.copy`<br>method::<br><br>   newdict = olddict.copy()<br><br>Sequences can be copied by slicing::<br><br>   new_l = l[:]<br><br><br>How can I find the methods or attributes of an object?<br>------------------------------------------------------<br><br>For an instance x of a user-defined class, ``dir(x)`` returns an alphabetized<br>list of the names containing the instance attributes and methods and attributes<br>defined by its class.<br><br><br>How can my code discover the name of an object?<br>-----------------------------------------------<br><br>Generally speaking, it  not, because objects do not really have names.<br>Essentially, assignment always binds a name to a value; The same is true of<br>``def`` and ``class`` statements, but in that case the value is a<br>callable. Consider the following code::<br><br>   >>> class A:<br>   ...     pass<br>   ...<br>   >>> B = A<br>   >>> a = B()<br>   >>> b = a<br>   >>> print(b)<br>   <__main__.A object at 0x16D07CC><br>   >>> print(a)<br>   <__main__.A object at 0x16D07CC><br><br>Arguably the class has a name: even though it is bound to two names and invoked<br>through the name B the created instance is still reported as an instance of<br>class A.  However, it is impossible to say whether the instance is name is a or<br>b, since both names are bound to the same value.<br><br>Generally speaking it should not be necessary for your code to "know the names"<br>of particular values. Unless you are deliberately writing introspective<br>programs, this is usually an indication that a change of approach might be<br>beneficial.<br><br>In comp.lang.python, Fredrik Lundh once gave an excellent analogy in answer to<br>this question:<br><br>   The same way as you get the name of that cat you found on your porch: the cat<br>   (object) itself cannot tell you its name, and it does not really care -- so<br>   the only way to find out what it is called is to ask all your neighbours<br>   (namespaces) if it is their cat (object)...<br><br>   ....and do not be surprised if you will find that it is known by many names, or<br>   no name at all!<br><br><br>What is up with the comma operator is precedence?<br>-----------------------------------------------<br><br>Comma is not an operator in Python.  Consider this session::<br><br>    >>> "a" in "b", "a"<br>    (False, 'a')<br><br>Since the comma is not an operator, but a separator between expressions the<br>above is evaluated as if you had entered::<br><br>    ("a" in "b"), "a"<br><br>not::<br><br>    "a" in ("b", "a")<br><br>The same is true of the various assignment operators (``=``, ``+=`` etc).  They<br>are not truly operators but syntactic delimiters in assignment statements.<br><br><br>Is there an equivalent of C is "?:" ternary operator?<br>----------------------------------------------------<br><br>Yes, there is. The syntax is as follows::<br><br>   [on_true] if [expression] else [on_false]<br><br>   x, y = 50, 25<br>   small = x if x < y else y<br><br>Before this syntax was introduced in Python 2.5, a common idiom was to use<br>logical operators::<br><br>   [expression] and [on_true] or [on_false]<br><br>However, this idiom is unsafe, as it can give wrong results when *on_true*<br>has a false boolean value.  Therefore, it is always better to use<br>the ``... if ... else ...`` form.<br><br><br>Is it possible to write obfuscated one-liners in Python?<br>--------------------------------------------------------<br><br>Yes.  Usually this is done by nesting :keyword:`lambda` within<br>:keyword:`lambda`.  See the following three examples, due to Ulf Bartelt::<br><br>   from functools import reduce<br><br>   # Primes < 1000<br>   print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,<br>   map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))<br><br>   # First 10 Fibonacci numbers<br>   print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:<br>   f(x,f), range(10))))<br><br>   # Mandelbrot set<br>   print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,<br>   Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,<br>   Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,<br>   i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y<br>   >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(<br>   64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy<br>   ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))<br>   #    \___ ___/  \___ ___/  |   |   |__ lines on screen<br>   #        V          V      |   |______ columns on screen<br>   #        |          |      |__________ maximum of "iterations"<br>   #        |          |_________________ range on y axis<br>   #        |____________________________ range on x axis<br><br>Do not try this at home, kids!<br><br><br>Numbers and strings<br>===================<br><br>How do I specify hexadecimal and octal integers?<br>------------------------------------------------<br><br>To specify an octal digit, precede the octal value with a zero, and then a lower<br>or uppercase "o".  For example, to set the variable "a" to the octal value "10"<br>(8 in decimal), type::<br><br>   >>> a = 0o10<br>   >>> a<br>   8<br><br>Hexadecimal is just as easy.  Simply precede the hexadecimal number with a zero,<br>and then a lower or uppercase "x".  Hexadecimal digits can be specified in lower<br>or uppercase.  For example, in the Python interpreter::<br><br>   >>> a = 0xa5<br>   >>> a<br>   165<br>   >>> b = 0XB2<br>   >>> b<br>   178<br><br><br>Why does -22 // 10 return -3?<br>-----------------------------<br><br>It is primarily driven by the desire that ``i % j`` have the same sign as ``j``.<br>If you want that, and also want::<br><br>    i == (i // j) * j + (i % j)<br><br>then integer division has to return the floor.  C also requires that identity to<br>hold, and then compilers that truncate ``i // j`` need to make ``i % j`` have<br>the same sign as ``i``.<br><br>There are few real use cases for ``i % j`` when ``j`` is negative.  When ``j``<br>is positive, there are many, and in virtually all of them it is more useful for<br>``i % j`` to be ``>= 0``.  If the clock says 10 now, what did it say 200 hours<br>ago?  ``-190 % 12 == 2`` is useful; ``-190 % 12 == -10`` is a bug waiting to<br>bite.<br><br><br>How do I convert a string to a number?<br>--------------------------------------<br><br>For integers, use the built-in :func:`int` type constructor, e.g. ``int('144')<br>== 144``.  Similarly, :func:`float` converts to floating-point,<br>e.g. ``float('144') == 144.0``.<br><br>By default, these interpret the number as decimal, so that ``int('0144') ==<br>144`` and ``int('0x144')`` raises :exc:`ValueError`. ``int(string, base)`` takes<br>the base to convert from as a second optional argument, so ``int('0x144', 16) ==<br>324``.  If the base is specified as 0, the number is interpreted using Python is<br>rules: a leading '0o' indicates octal, and '0x' indicates a hex number.<br><br>Do not use the built-in function :func:`eval` if all you need is to convert<br>strings to numbers.  :func:`eval` will be significantly slower and it presents a<br>security risk: someone could pass you a Python expression that might have<br>unwanted side effects.  For example, someone could pass<br>``__import__('os').system("rm -rf $HOME")`` which would erase your home<br>directory.<br><br>:func:`eval` also has the effect of interpreting numbers as Python expressions,<br>so that e.g. ``eval('09')`` gives a syntax error because Python does not allow<br>leading '0' in a decimal number (except '0').<br><br><br>How do I convert a number to a string?<br>--------------------------------------<br><br>To convert, e.g., the number 144 to the string '144', use the built-in type<br>constructor :func:`str`.  If you want a hexadecimal or octal representation, use<br>the built-in functions :func:`hex` or :func:`oct`.  For fancy formatting, see<br>the :ref:`formatstrings` section, e.g. ``"{:04d}".format(144)`` yields<br>``'0144'`` and ``"{:.3f}".format(1.0/3.0)`` yields ``'0.333'``.<br><br><br>How do I modify a string in place?<br>----------------------------------<br><br>You  not, because strings are immutable.  In most situations, you should<br>simply construct a new string from the various parts you want to assemble<br>it from.  However, if you need an object with the ability to modify in-place<br>unicode data, try using an :class:`io.StringIO` object or the :mod:`array`<br>module::<br><br>   >>> import io<br>   >>> s = "Hello, world"<br>   >>> sio = io.StringIO(s)<br>   >>> sio.getvalue()<br>   'Hello, world'<br>   >>> sio.seek(7)<br>   7<br>   >>> sio.write("there!")<br>   6<br>   >>> sio.getvalue()<br>   'Hello, there!'<br><br>   >>> import array<br>   >>> a = array.array('u', s)<br>   >>> print(a)<br>   array('u', 'Hello, world')<br>   >>> a[0] = 'y'<br>   >>> print(a)<br>   array('u', 'yello, world')<br>   >>> a.tounicode()<br>   'yello, world'<br><br><br>How do I use strings to call functions/methods?<br>-----------------------------------------------<br><br>There are various techniques.<br><br>* The best is to use a dictionary that maps strings to functions.  The primary<br>  advantage of this technique is that the strings do not need to match the names<br>  of the functions.  This is also the primary technique used to emulate a case<br>  construct::<br><br>     def a():<br>         pass<br><br>     def b():<br>         pass<br><br>     dispatch = {'go': a,  istop': b}  # Note lack of parens for funcs<br><br>     dispatch[get_input()]()  # Note trailing parens to call function<br><br>* Use the built-in function :func:`getattr`::<br><br>     import foo<br>     getattr(foo, 'bar')()<br><br>  Note that :func:`getattr` works on any object, including classes, class<br>  instances, modules, and so on.<br><br>  This is used in several places in the standard library, like this::<br><br>     class Foo:<br>         def do_foo(self):<br>             ...<br><br>         def do_bar(self):<br>             ...<br><br>     f = getattr(foo_instance,  wouldo_' + opname)<br>     f()<br><br><br>* Use :func:`locals` or :func:`eval` to resolve the function name::<br><br>     def myFunc():<br>         print("hello")<br><br>     fname = "myFunc"<br><br>     f = locals()[fname]<br>     f()<br><br>     f = eval(fname)<br>     f()<br><br>  Note: Using :func:`eval` is slow and dangerous.  If you do not have absolute<br>  control over the contents of the string, someone could pass a string that<br>  resulted in an arbitrary function being executed.<br><br>Is there an equivalent to Perl is chomp() for removing trailing newlines from strings?<br>-------------------------------------------------------------------------------------<br><br>You can use ``S.rstrip("\r\n")`` to remove all occurrences of any line<br>terminator from the end of the string ``S`` without removing other trailing<br>whitespace.  If the string ``S`` represents more than one line, with several<br>empty lines at the end, the line terminators for all the blank lines will<br>be removed::<br><br>   >>> lines = ("line 1 \r\n"<br>   ...          "\r\n"<br>   ...          "\r\n")<br>   >>> lines.rstrip("\n\r")<br>   'line 1 '<br><br>Since this is typically only desired when reading text one line at a time, using<br>``S.rstrip()`` this way works well.<br><br><br>Is there a scanf() or sscanf() equivalent?<br>------------------------------------------<br><br>Not as such.<br><br>For simple input parsing, the easiest approach is usually to split the line into<br>whitespace-delimited words using the :meth:`~str.split` method of string objects<br>and then convert decimal strings to numeric values using :func:`int` or<br>:func:`float`.  ``split()`` supports an optional "sep" parameter which is useful<br>if the line uses something other than whitespace as a separator.<br><br>For more complicated input parsing, regular expressions are more powerful<br>than C is :c:func:`sscanf` and better suited for the task.<br><br><br>What does 'UnicodeDecodeError' or 'UnicodeEncodeError' error  mean?<br>-------------------------------------------------------------------<br><br>See the :ref:`unicode-howto`.<br><br><br>Performance<br>===========<br><br>My program is too slow. How do I speed it up?<br>---------------------------------------------<br><br>That is a tough one, in general.  First, here are a list of things to<br>remember before diving further:<br><br>* Performance characteristics vary across Python implementations.  This FAQ<br>  focusses on :term:`CPython`.<br>* Behaviour can vary across operating systems, especially when talking about<br>  I/O or multi-threading.<br>* You should always find the hot spots in your program *before* attempting to<br>  optimize any code (see the :mod:`profile` module).<br>* Writing benchmark scripts will allow you to iterate quickly when searching<br>  for improvements (see the :mod:`timeit` module).<br>* It is highly recommended to have good code coverage (through unit testing<br>  or any other technique) before potentially introducing regressions hidden<br>  in sophisticated optimizations.<br><br>That being said, there are many tricks to speed up Python code.  Here are<br>some general principles which go a long way towards reaching acceptable<br>performance levels:<br><br>* Making your algorithms faster (or changing to faster ones) can yield<br>  much larger benefits than trying to sprinkle micro-optimization tricks<br>  all over your code.<br><br>* Use the right data structures.  Study documentation for the :ref:`bltin-types`<br>  and the :mod:`collections` module.<br><br>* When the standard library provides a primitive for doing something, it is<br>  likely (although not guaranteed) to be faster than any alternative you<br>  may come up with.  This is doubly true for primitives written in C, such<br>  as builtins and some extension types.  For example, be sure to use<br>  either the :meth:`list.sort` built-in method or the related :func:`sorted`<br>  function to do sorting (and see the :ref:`sortinghowto` for examples<br>  of moderately advanced usage).<br><br>* Abstractions tend to create indirections and force the interpreter to work<br>  more.  If the levels of indirection outweigh the amount of useful work<br>  done, your program will be slower.  You should avoid excessive abstraction,<br>  especially under the form of tiny functions or methods (which are also often<br>  detrimental to readability).<br><br>If you have reached the limit of what pure Python can allow, there are tools<br>to take you further away.  For example, `Cython <http://cython.org>`_ can<br>compile a slightly modified version of Python code into a C extension, and<br>can be used on many different platforms.  Cython can take advantage of<br>compilation (and optional type annotations) to make your code significantly<br>faster than when interpreted.  If you are confident in your C programming<br>skills, you can also :ref:`write a C extension module <extending-index>`<br>yourself.<br><br>.. seealso::<br>   The wiki page devoted to `performance tips<br>   <https://wiki.python.org/moin/PythonSpeed/PerformanceTips>`_.<br><br>.. _efficient_string_concatenation:<br><br>What is the most efficient way to concatenate many strings together?<br>--------------------------------------------------------------------<br><br>:class:`str` and :class:`bytes` objects are immutable, therefore concatenating<br>many strings together is inefficient as each concatenation creates a new<br>object.  In the general case, the total runtime cost is quadratic in the<br>total string length.<br><br>To accumulate many :class:`str` objects, the recommended idiom is to place<br>them into a list and call :meth:`str.join` at the end::<br><br>   chunks = []<br>   for s in my_strings:<br>       chunks.append(s)<br>   result = ''.join(chunks)<br><br>(another reasonably efficient idiom is to use :class:`io.StringIO`)<br><br>To accumulate many :class:`bytes` objects, the recommended idiom is to extend<br>a :class:`bytearray` object using in-place concatenation (the ``+=`` operator)::<br><br>   result = bytearray()<br>   for b in my_bytes_objects:<br>       result += b<br><br><br>Sequences (Tuples/Lists)<br>========================<br><br>How do I convert between tuples and lists?<br>------------------------------------------<br><br>The type constructor ``tuple(seq)`` converts any sequence (actually, any<br>iterable) into a tuple with the same items in the same order.<br><br>For example, ``tuple([1, 2, 3])`` yields ``(1, 2, 3)`` and ``tuple('abc')``<br>yields ``('a', 'b', 'c')``.  If the argument is a tuple, it does not make a copy<br>but returns the same object, so it is cheap to call :func:`tuple` when you<br>are not sure that an object is already a tuple.<br><br>The type constructor ``list(seq)`` converts any sequence or iterable into a list<br>with the same items in the same order.  For example, ``list((1, 2, 3))`` yields<br>``[1, 2, 3]`` and ``list('abc')`` yields ``['a', 'b', 'c']``.  If the argument<br>is a list, it makes a copy just like ``seq[:]`` would.<br><br><br>What is a negative index?<br>------------------------<br><br>Python sequences are indexed with positive numbers and negative numbers.  For<br>positive numbers 0 is the first index 1 is the second index and so forth.  For<br>negative indices -1 is the last index and -2 is the penultimate (next to last)<br>index and so forth.  Think of ``seq[-n]`` as the same as ``seq[len(seq)-n]``.<br><br>Using negative indices can be very convenient.  For example ``S[:-1]`` is all of<br>the string except for its last character, which is useful for removing the<br>trailing newline from a string.<br><br><br>How do I iterate over a sequence in reverse order?<br>--------------------------------------------------<br><br>Use the :func:`reversed` built-in function, which is new in Python 2.4::<br><br>   for x in reversed(sequence):<br>       ...  # do something with x ...<br><br>This wo not touch your original sequence, but build a new copy with reversed<br>order to iterate over.<br><br>With Python 2.3, you can use an extended slice syntax::<br><br>   for x in sequence[::-1]:<br>       ...  # do something with x ...<br><br><br>How do you remove duplicates from a list?<br>-----------------------------------------<br><br>See the Python Cookbook for a long discussion of many ways to do this:<br><br>   https://code.activestate.com/recipes/52560/<br><br>If you do not mind reordering the list, sort it and then scan from the end of the<br>list, deleting duplicates as you go::<br><br>   if mylist:<br>       mylist.sort()<br>       last = mylist[-1]<br>       for i in range(len(mylist)-2, -1, -1):<br>           if last == mylist[i]:<br>               del mylist[i]<br>           else:<br>               last = mylist[i]<br><br>If all elements of the list may be used as set keys (i.e. they are all<br>:term:`hashable`) this is often faster ::<br><br>   mylist = list(set(mylist))<br><br>This converts the list into a set, thereby removing duplicates, and then back<br>into a list.<br><br><br>How do you make an array in Python?<br>-----------------------------------<br><br>Use a list::<br><br>   ["this", 1, "is", "an", "array"]<br><br>Lists are equivalent to C or Pascal arrays in their time complexity; the primary<br>difference is that a Python list can contain objects of many different types.<br><br>The ``array`` module also provides methods for creating arrays of fixed types<br>with compact representations, but they are slower to index than lists.  Also<br>note that the Numeric extensions and others define array-like structures with<br>various characteristics as well.<br><br>To get Lisp-style linked lists, you can emulate cons cells using tuples::<br><br>   lisp_list = ("like",  ("this",  ("example", None) ) )<br><br>If mutability is desired, you could use lists instead of tuples.  Here the<br>analogue of lisp car is ``lisp_list[0]`` and the analogue of cdr is<br>``lisp_list[1]``.  Only do this if you are sure you really need to, because it is<br>usually a lot slower than using Python lists.<br><br><br>.. _faq-multidimensional-list:<br><br>How do I create a multidimensional list?<br>----------------------------------------<br><br>You probably tried to make a multidimensional array like this::<br><br>   >>> A = [[None] * 2] * 3<br><br>This looks correct if you print it:<br><br>.. testsetup::<br><br>   A = [[None] * 2] * 3<br><br>.. doctest::<br><br>   >>> A<br>   [[None, None], [None, None], [None, None]]<br><br>But when you assign a value, it shows up in multiple places:<br><br>.. testsetup::<br><br>   A = [[None] * 2] * 3<br><br>.. doctest::<br><br>   >>> A[0][0] = 5<br>   >>> A<br>   [[5, None], [5, None], [5, None]]<br><br>The reason is that replicating a list with ``*`` does not create copies, it only<br>creates references to the existing objects.  The ``*3`` creates a list<br>containing 3 references to the same list of length two.  Changes to one row will<br>show in all rows, which is almost certainly not what you want.<br><br>The suggested approach is to create a list of the desired length first and then<br>fill in each element with a newly created list::<br><br>   A = [None] * 3<br>   for i in range(3):<br>       A[i] = [None] * 2<br><br>This generates a list containing 3 different lists of length two.  You can also<br>use a list comprehension::<br><br>   w, h = 2, 3<br>   A = [[None] * w for i in range(h)]<br><br>Or, you can use an extension that provides a matrix datatype; `NumPy<br><http://www.numpy.org/>`_ is the best known.<br><br><br>How do I apply a method to a sequence of objects?<br>-------------------------------------------------<br><br>Use a list comprehension::<br><br>   result = [obj.method() for obj in mylist]<br><br>.. _faq-augmented-assignment-tuple-error:<br><br>Why does a_tuple[i] += ['item'] raise an exception when the addition works?<br>---------------------------------------------------------------------------<br><br>This is because of a combination of the fact that augmented assignment<br>operators are *assignment* operators, and the difference between mutable and<br>immutable objects in Python.<br><br>This discussion applies in general when augmented assignment operators are<br>applied to elements of a tuple that point to mutable objects, but we will use<br>a ``list`` and ``+=`` as our exemplar.<br><br>If you wrote::<br><br>   >>> a_tuple = (1, 2)<br>   >>> a_tuple[0] += 1<br>   Traceback (most recent call last):<br>      ...<br>   TypeError: 'tuple' object does not support item assignment<br><br>The reason for the exception should be immediately clear: ``1`` is added to the<br>object ``a_tuple[0]`` points to (``1``), producing the result object, ``2``,<br>but when we attempt to assign the result of the computation, ``2``, to element<br>``0`` of the tuple, we get an error because we  not change what an element of<br>a tuple points to.<br><br>Under the covers, what this augmented assignment statement is doing is<br>approximately this::<br><br>   >>> result = a_tuple[0] + 1<br>   >>> a_tuple[0] = result<br>   Traceback (most recent call last):<br>     ...<br>   TypeError: 'tuple' object does not support item assignment<br><br>It is the assignment part of the operation that produces the error, since a<br>tuple is immutable.<br><br>When you write something like::<br><br>   >>> a_tuple = (['foo'], 'bar')<br>   >>> a_tuple[0] += ['item']<br>   Traceback (most recent call last):<br>     ...<br>   TypeError: 'tuple' object does not support item assignment<br><br>The exception is a bit more surprising, and even more surprising is the fact<br>that even though there was an error, the append worked::<br><br>    >>> a_tuple[0]<br>    ['foo', 'item']<br><br>To see why this happens, you need to know that (a) if an object implements an<br>``__iadd__`` magic method, it gets called when the ``+=`` augmented assignment<br>is executed, and its return value is what gets used in the assignment statement;<br>and (b) for lists, ``__iadd__`` is equivalent to calling ``extend`` on the list<br>and returning the list.  That is why we say that for lists, ``+=`` is a<br>"shorthand" for ``list.extend``::<br><br>    >>> a_list = []<br>    >>> a_list += [1]<br>    >>> a_list<br>    [1]<br><br>This is equivalent to::<br><br>    >>> result = a_list.__iadd__([1])<br>    >>> a_list = result<br><br>The object pointed to by a_list has been mutated, and the pointer to the<br>mutated object is assigned back to ``a_list``.  The end result of the<br>assignment is a no-op, since it is a pointer to the same object that ``a_list``<br>was previously pointing to, but the assignment still happens.<br><br>Thus, in our tuple example what is happening is equivalent to::<br><br>   >>> result = a_tuple[0].__iadd__(['item'])<br>   >>> a_tuple[0] = result<br>   Traceback (most recent call last):<br>     ...<br>   TypeError: 'tuple' object does not support item assignment<br><br>The ``__iadd__`` succeeds, and thus the list is extended, but even though<br>``result`` points to the same object that ``a_tuple[0]`` already points to,<br>that final assignment still results in an error, because tuples are immutable.<br><br><br>Dictionaries<br>============<br><br>How can I get a dictionary to store and display its keys in a consistent order?<br>-------------------------------------------------------------------------------<br><br>Use :class:`collections.OrderedDict`.<br><br>I want to do a complicated sort: can you do a Schwartzian Transform in Python?<br>------------------------------------------------------------------------------<br><br>The technique, attributed to Randal Schwartz of the Perl community, sorts the<br>elements of a list by a metric which maps each element to its "sort value". In<br>Python, use the ``key`` argument for the :meth:`list.sort` method::<br><br>   Isorted = L[:]<br>   Isorted.sort(key=lambda s: int(s[10:15]))<br><br><br>How can I sort one list by values from another list?<br>----------------------------------------------------<br><br>Merge them into an iterator of tuples, sort the resulting list, and then pick<br>out the element you want. ::<br><br>   >>> list1 = ["what", "I am", "sorting", "by"]<br>   >>> list2 = ["something", "else", "to", "sort"]<br>   >>> pairs = zip(list1, list2)<br>   >>> pairs = sorted(pairs)<br>   >>> pairs<br>   [("I am", 'else'), ('by',  isort'), ( isorting', 'to'), ('what',  isomething')]<br>   >>> result = [x[1] for x in pairs]<br>   >>> result<br>   ['else',  isort', 'to',  isomething']<br><br><br>An alternative for the last step is::<br><br>   >>> result = []<br>   >>> for p in pairs: result.append(p[1])<br><br>If you find this more legible, you might prefer to use this instead of the final<br>list comprehension.  However, it is almost twice as slow for long lists.  Why?<br>First, the ``append()`` operation has to reallocate memory, and while it uses<br>some tricks to avoid doing that each time, it still has to do it occasionally,<br>and that costs quite a bit.  Second, the expression "result.append" requires an<br>extra attribute lookup, and third, there is a speed reduction from having to make<br>all those function calls.<br><br><br>Objects<br>=======<br><br>What is a class?<br>----------------<br><br>A class is the particular object type created by executing a class statement.<br>Class objects are used as templates to create instance objects, which embody<br>both the data (attributes) and code (methods) specific to a datatype.<br><br>A class can be based on one or more other classes, called its base class(es). It<br>then inherits the attributes and methods of its base classes. This allows an<br>object model to be successively refined by inheritance.  You might have a<br>generic ``Mailbox`` class that provides basic accessor methods for a mailbox,<br>and subclasses such as ``MboxMailbox``, ``MaildirMailbox``, ``OutlookMailbox``<br>that handle various specific mailbox formats.<br><br><br>What is a method?<br>-----------------<br><br>A method is a function on some object ``x`` that you normally call as<br>``x.name(arguments...)``.  Methods are defined as functions inside the class<br>definition::<br><br>   class C:<br>       def meth(self, arg):<br>           return arg * 2 + self.attribute<br><br><br>What is self?<br>-------------<br><br>Self is merely a conventional name for the first argument of a method.  A method<br>defined as ``meth(self, a, b, c)`` should be called as ``x.meth(a, b, c)`` for<br>some instance ``x`` of the class in which the definition occurs; the called<br>method will think it is called as ``meth(x, a, b, c)``.<br><br>See also :ref:`why-self`.<br><br><br>How do I check if an object is an instance of a given class or of a subclass of it?<br>-----------------------------------------------------------------------------------<br><br>Use the built-in function ``isinstance(obj, cls)``.  You can check if an object<br>is an instance of any of a number of classes by providing a tuple instead of a<br>single class, e.g. ``isinstance(obj, (class1, class2, ...))``, and can also<br>check whether an object is one of Python is built-in types, e.g.<br>``isinstance(obj, str)`` or ``isinstance(obj, (int, float, complex))``.<br><br>Note that most programs do not use :func:`isinstance` on user-defined classes<br>very often.  If you are developing the classes yourself, a more proper<br>object-oriented style is to define methods on the classes that encapsulate a<br>particular behaviour, instead of checking the object is class and doing a<br>different thing based on what class it is.  For example, if you have a function<br>that does something::<br><br>   def search(obj):<br>       if isinstance(obj, Mailbox):<br>           ...  # code to search a mailbox<br>       elif isinstance(obj, Document):<br>           ...  # code to search a document<br>       elif ...<br><br>A better approach is to define a ``search()`` method on all the classes and just<br>call it::<br><br>   class Mailbox:<br>       def search(self):<br>           ...  # code to search a mailbox<br><br>   class Document:<br>       def search(self):<br>           ...  # code to search a document<br><br>   obj.search()<br><br><br>What is delegation?<br>-------------------<br><br>Delegation is an object oriented technique (also called a design pattern).<br>Let is say you have an object ``x`` and want to change the behaviour of just one<br>of its methods.  You can create a new class that provides a new implementation<br>of the method you are interested in changing and delegates all other methods to<br>the corresponding method of ``x``.<br><br>Python programmers can easily implement delegation.  For example, the following<br>class implements a class that behaves like a file but converts all written data<br>to uppercase::<br><br>   class UpperOut:<br><br>       def __init__(self, outfile):<br>           self._outfile = outfile<br><br>       def write(self, s):<br>           self._outfile.write(s.upper())<br><br>       def __getattr__(self, name):<br>           return getattr(self._outfile, name)<br><br>Here the ``UpperOut`` class redefines the ``write()`` method to convert the<br>argument string to uppercase before calling the underlying<br>``self.__outfile.write()`` method.  All other methods are delegated to the<br>underlying ``self.__outfile`` object.  The delegation is accomplished via the<br>``__getattr__`` method; consult :ref:`the language reference <attribute-access>`<br>for more information about controlling attribute access.<br><br>Note that for more general cases delegation can get trickier. When attributes<br>must be set as well as retrieved, the class must define a :meth:`__setattr__`<br>method too, and it must do so carefully.  The basic implementation of<br>:meth:`__setattr__` is roughly equivalent to the following::<br><br>   class X:<br>       ...<br>       def __setattr__(self, name, value):<br>           self.__dict__[name] = value<br>       ...<br><br>Most :meth:`__setattr__` implementations must modify ``self.__dict__`` to store<br>local state for self without causing an infinite recursion.<br><br><br>How do I call a method defined in a base class from a derived class that overrides it?<br>--------------------------------------------------------------------------------------<br><br>Use the built-in :func:`super` function::<br><br>   class Derived(Base):<br>       def meth(self):<br>           super(Derived, self).meth()<br><br>For version prior to 3.0, you may be using classic classes: For a class<br>definition such as ``class Derived(Base): ...`` you can call method ``meth()``<br>defined in ``Base`` (or one of ``Base`` is base classes) as ``Base.meth(self,<br>arguments...)``.  Here, ``Base.meth`` is an unbound method, so you need to<br>provide the ``self`` argument.<br><br><br>How can I organize my code to make it easier to change the base class?<br>----------------------------------------------------------------------<br><br>You could define an alias for the base class, assign the real base class to it<br>before your class definition, and use the alias throughout your class.  Then all<br>you have to change is the value assigned to the alias.  Incidentally, this trick<br>is also handy if you want to decide dynamically (e.g. depending on availability<br>of resources) which base class to use.  Example::<br><br>   BaseAlias = <real base class><br><br>   class Derived(BaseAlias):<br>       def meth(self):<br>           BaseAlias.meth(self)<br>           ...<br><br><br>How do I create static class data and static class methods?<br>-----------------------------------------------------------<br><br>Both static data and static methods (in the sense of C++ or Java) are supported<br>in Python.<br><br>For static data, simply define a class attribute.  To assign a new value to the<br>attribute, you have to explicitly use the class name in the assignment::<br><br>   class C:<br>       count = 0   # number of times C.__init__ called<br><br>       def __init__(self):<br>           C.count = C.count + 1<br><br>       def getcount(self):<br>           return C.count  # or return self.count<br><br>``c.count`` also refers to ``C.count`` for any ``c`` such that ``isinstance(c,<br>C)`` holds, unless overridden by ``c`` itself or by some class on the base-class<br>search path from ``c.__class__`` back to ``C``.<br><br>Caution: within a method of C, an assignment like ``self.count = 42`` creates a<br>new and unrelated instance named "count" in ``self`` is own dict.  Rebinding of a<br>class-static data name must always specify the class whether inside a method or<br>not::<br><br>   C.count = 314<br><br>Static methods are possible::<br><br>   class C:<br>       @staticmethod<br>       def static(arg1, arg2, arg3):<br>           # No  iself' parameter!<br>           ...<br><br>However, a far more straightforward way to get the effect of a static method is<br>via a simple module-level function::<br><br>   def getcount():<br>       return C.count<br><br>If your code is structured so as to define one class (or tightly related class<br>hierarchy) per module, this supplies the desired encapsulation.<br><br><br>How can I overload constructors (or methods) in Python?<br>-------------------------------------------------------<br><br>This answer actually applies to all methods, but the question usually comes up<br>first in the context of constructors.<br><br>In C++ you would write<br><br>.. code-block:: c<br><br>    class C {<br>        C() { cout << "No arguments\n"; }<br>        C(int i) { cout << "Argument is " << i << "\n"; }<br>    }<br><br>In Python you have to write a single constructor that catches all cases using<br>default arguments.  For example::<br><br>   class C:<br>       def __init__(self, i=None):<br>           if i is None:<br>               print("No arguments")<br>           else:<br>               print("Argument is", i)<br><br>This is not entirely equivalent, but close enough in practice.<br><br>You could also try a variable-length argument list, e.g. ::<br><br>   def __init__(self, *args):<br>       ...<br><br>The same approach works for all method definitions.<br><br><br>I try to use __spam and I get an error about _SomeClassName__spam.<br>------------------------------------------------------------------<br><br>Variable names with double leading underscores are "mangled" to provide a simple<br>but effective way to define class private variables.  Any identifier of the form<br>``__spam`` (at least two leading underscores, at most one trailing underscore)<br>is textually replaced with ``_classname__spam``, where ``classname`` is the<br>current class name with any leading underscores stripped.<br><br>This does not guarantee privacy: an outside user can still deliberately access<br>the "_classname__spam" attribute, and private values are visible in the object is<br>``__dict__``.  Many Python programmers never bother to use private variable<br>names at all.<br><br><br>My class defines __del__ but it is not called when I delete the object.<br>-----------------------------------------------------------------------<br><br>There are several possible reasons for this.<br><br>The del statement does not necessarily call :meth:`__del__` -- it simply<br>decrements the object is reference count, and if this reaches zero<br>:meth:`__del__` is called.<br><br>If your data structures contain circular links (e.g. a tree where each child has<br>a parent reference and each parent has a list of children) the reference counts<br>will never go back to zero.  Once in a while Python runs an algorithm to detect<br>such cycles, but the garbage collector might run some time after the last<br>reference to your data structure vanishes, so your :meth:`__del__` method may be<br>called at an inconvenient and random time. This is inconvenient if you are trying<br>to reproduce a problem. Worse, the order in which object is :meth:`__del__`<br>methods are executed is arbitrary.  You can run :func:`gc.collect` to force a<br>collection, but there *are* pathological cases where objects will never be<br>collected.<br><br>Despite the cycle collector, it is still a good idea to define an explicit<br>``close()`` method on objects to be called whenever you are done with them.  The<br>``close()`` method can then remove attributes that refer to subobjecs.  Do not<br>call :meth:`__del__` directly -- :meth:`__del__` should call ``close()`` and<br>``close()`` should make sure that it can be called more than once for the same<br>object.<br><br>Another way to avoid cyclical references is to use the :mod:`weakref` module,<br>which allows you to point to objects without incrementing their reference count.<br>Tree data structures, for instance, should use weak references for their parent<br>and sibling references (if they need them!).<br><br>.. XXX relevant for Python 3?<br><br>   If the object has ever been a local variable in a function that caught an<br>   expression in an except clause, chances are that a reference to the object<br>   still exists in that function is stack frame as contained in the stack trace.<br>   Normally, calling :func:`sys.exc_clear` will take care of this by clearing<br>   the last recorded exception.<br><br>Finally, if your :meth:`__del__` method raises an exception, a warning message<br>is printed to :data:`sys.stderr`.<br><br><br>How do I get a list of all instances of a given class?<br>------------------------------------------------------<br><br>Python does not keep track of all instances of a class (or of a built-in type).<br>You can program the class is constructor to keep track of all instances by<br>keeping a list of weak references to each instance.<br><br><br>Why does the result of ``id()`` appear to be not unique?<br>--------------------------------------------------------<br><br>The :func:`id` builtin returns an integer that is guaranteed to be unique during<br>the lifetime of the object.  Since in CPython, this is the object is memory<br>address, it happens frequently that after an object is deleted from memory, the<br>next freshly created object is allocated at the same position in memory.  This<br>is illustrated by this example:<br><br>>>> id(1000) # doctest: +SKIP<br>13901272<br>>>> id(2000) # doctest: +SKIP<br>13901272<br><br>The two ids belong to different integer objects that are created before, and<br>deleted immediately after execution of the ``id()`` call.  To be sure that<br>objects whose id you want to examine are still alive, create another reference<br>to the object:<br><br>>>> a = 1000; b = 2000<br>>>> id(a) # doctest: +SKIP<br>13901272<br>>>> id(b) # doctest: +SKIP<br>13891296<br><br><br>Modules<br>=======<br><br>How do I create a .pyc file?<br>----------------------------<br><br>When a module is imported for the first time (or when the source file has<br>changed since the current compiled file was created) a ``.pyc`` file containing<br>the compiled code should be created in a ``__pycache__`` subdirectory of the<br>directory containing the ``.py`` file.  The ``.pyc`` file will have a<br>filename that starts with the same name as the ``.py`` file, and ends with<br>``.pyc``, with a middle component that depends on the particular ``python``<br>binary that created it.  (See :pep:`3147` for details.)<br><br>One reason that a ``.pyc`` file may not be created is a permissions problem<br>with the directory containing the source file, meaning that the ``__pycache__``<br>subdirectory cannot be created. This can happen, for example, if you develop as<br>one user but run as another, such as if you are testing with a web server.<br><br>Unless the :envvar:`PYTHONDONTWRITEBYTECODE` environment variable is set,<br>creation of a .pyc file is automatic if you are importing a module and Python<br>has the ability (permissions, free space, etc...) to create a ``__pycache__``<br>subdirectory and write the compiled module to that subdirectory.<br><br>Running Python on a top level script is not considered an import and no<br>``.pyc`` will be created.  For example, if you have a top-level module<br>``foo.py`` that imports another module ``xyz.py``, when you run ``foo`` (by<br>typing ``python foo.py`` as a shell command), a ``.pyc`` will be created for<br>``xyz`` because ``xyz`` is imported, but no ``.pyc`` file will be created for<br>``foo`` since ``foo.py`` is not being imported.<br><br>If you need to create a ``.pyc`` file for ``foo`` -- that is, to create a<br>``.pyc`` file for a module that is not imported -- you can, using the<br>:mod:`py_compile` and :mod:`compileall` modules.<br><br>The :mod:`py_compile` module can manually compile any module.  One way is to use<br>the ``compile()`` function in that module interactively::<br><br>   >>> import py_compile<br>   >>> py_compile.compile('foo.py')                 # doctest: +SKIP<br><br>This will write the ``.pyc`` to a ``__pycache__`` subdirectory in the same<br>location as ``foo.py`` (or you can override that with the optional parameter<br>``cfile``).<br><br>You can also automatically compile all files in a directory or directories using<br>the :mod:`compileall` module.  You can do it from the shell prompt by running<br>``compileall.py`` and providing the path of a directory containing Python files<br>to compile::<br><br>       python -m compileall .<br><br><br>How do I find the current module name?<br>--------------------------------------<br><br>A module can find out its own module name by looking at the predefined global<br>variable ``__name__``.  If this has the value ``'__main__'``, the program is<br>running as a script.  Many modules that are usually used by importing them also<br>provide a command-line interface or a self-test, and only execute this code<br>after checking ``__name__``::<br><br>   def main():<br>       print('Running test...')<br>       ...<br><br>   if __name__ == '__main__':<br>       main()<br><br><br>How can I have modules that mutually import each other?<br>-------------------------------------------------------<br><br>Suppose you have the following modules:<br><br>foo.py::<br><br>   from bar import bar_var<br>   foo_var = 1<br><br>bar.py::<br><br>   from foo import foo_var<br>   bar_var = 2<br><br>The problem is that the interpreter will perform the following steps:<br><br>* main imports foo<br>* Empty globals for foo are created<br>* foo is compiled and starts executing<br>* foo imports bar<br>* Empty globals for bar are created<br>* bar is compiled and starts executing<br>* bar imports foo (which is a no-op since there already is a module named foo)<br>* bar.foo_var = foo.foo_var<br><br>The last step fails, because Python is not done with interpreting ``foo`` yet and<br>the global symbol dictionary for ``foo`` is still empty.<br><br>The same thing happens when you use ``import foo``, and then try to access<br>``foo.foo_var`` in global code.<br><br>There are (at least) three possible workarounds for this problem.<br><br>Guido van Rossum recommends avoiding all uses of ``from <module> import ...``,<br>and placing all code inside functions.  Initializations of global variables and<br>class variables should use constants or built-in functions only.  This means<br>everything from an imported module is referenced as ``<module>.<name>``.<br><br>Jim Roskind suggests performing steps in the following order in each module:<br><br>* exports (globals, functions, and classes that do not need imported base<br>  classes)<br>* ``import`` statements<br>* active code (including globals that are initialized from imported values).<br><br>van Rossum does not like this approach much because the imports appear in a<br>strange place, but it does work.<br><br>Matthias Urlichs recommends restructuring your code so that the recursive import<br>is not necessary in the first place.<br><br>These solutions are not mutually exclusive.<br><br><br>__import__('x.y.z') returns <module 'x'>; how do I get z?<br>---------------------------------------------------------<br><br>Consider using the convenience function :func:`~importlib.import_module` from<br>:mod:`importlib` instead::<br><br>   z = importlib.import_module('x.y.z')<br><br><br>When I edit an imported module and reimport it, the changes do not show up.  Why does this happen?<br>-------------------------------------------------------------------------------------------------<br><br>For reasons of efficiency as well as consistency, Python only reads the module<br>file on the first time a module is imported.  If it did not, in a program<br>consisting of many modules where each one imports the same basic module, the<br>basic module would be parsed and re-parsed many times.  To force re-reading of a<br>changed module, do this::<br><br>   import importlib<br>   import modname<br>   importlib.reload(modname)<br><br>Warning: this technique is not 100% fool-proof.  In particular, modules<br>containing statements like ::<br><br>   from modname import some_objects<br><br>will continue to work with the old version of the imported objects.  If the<br>module contains class definitions, existing class instances will *not* be<br>updated to use the new class definition.  This can result in the following<br>paradoxical behaviour:<br><br>   >>> import importlib<br>   >>> import cls<br>   >>> c = cls.C()                # Create an instance of C<br>   >>> importlib.reload(cls)<br>   <module 'cls' from 'cls.py'><br>   >>> isinstance(c, cls.C)       # isinstance is false?!?<br>   False<br><br>The nature of the problem is made clear if you print out the "identity" of the<br>class objects:<br><br>   >>> hex(id(c.__class__))<br>   '0x7352a0'<br>   >>> hex(id(cls.C))<br>   '0x4198d0'<br></body> </html>